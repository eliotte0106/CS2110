#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"

#include "images/ball.h"
#include "images/goalpost.h"
#include "images/end.h"
#include "images/start.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  OVER,
  SCORE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  struct pos b = {0, (HEIGHT - BALL_HEIGHT)};
  const struct pos gp = {WIDTH - GOALPOST_WIDTH, (HEIGHT - GOALPOST_HEIGHT) / 2};

  int time = 0;
  char arr[100];
  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();

    switch (state) {
      case START:
        drawFullScreenImageDMA(start);
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          fillScreenDMA(WHITE);
          vBlankCounter = 0;
          state = PLAY;
        }
        // state = ?
        break;
      case PLAY:
        snprintf(arr, 100, "Score: %d", time);

        drawString(0, 0, arr, BLACK);

        time = vBlankCounter / 60;

        snprintf(arr, 100, "Score: %d", time);

        drawString(0, 0, arr, BLACK);
        //drawRectDMA(b.col, b.row, BALL_WIDTH, BALL_HEIGHT, WHITE);
        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          b.row++;
        }
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          if (b.row > 0) {
            b.row--;
          }
        }
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          if (b.col > 0) {
            b.col--;
          }
        }
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          if (b.col < HEIGHT - BALL_HEIGHT) {
            b.col++;
          }
        }

        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          b.col = HEIGHT - BALL_HEIGHT;
          b.row = 0;
          vBlankCounter = 0;
        }
        if (b.row + BALL_WIDTH == gp.row) {
          state = OVER;
        }
      
        drawImageDMA(b.col, b.row, BALL_WIDTH, BALL_HEIGHT, ball);
        drawImageDMA(gp.col, gp.row, GOALPOST_WIDTH, GOALPOST_HEIGHT, goalpost);
        // state = ?
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          b.col = HEIGHT - BALL_HEIGHT;
          b.row = 0;
          vBlankCounter = 0;
        }
        break;
      case OVER:
        drawFullScreenImageDMA(end);
        // state = ?
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          fillScreenDMA(WHITE);
          vBlankCounter = 0;
          state = SCORE;
        }
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          b.col = HEIGHT - BALL_HEIGHT;
          b.row = 0;
          vBlankCounter = 0;
        }
        break;
      case SCORE:
        snprintf(arr,100,"Your Score: %d", time);
        drawString(100, 80, arr, BLACK);
        // state = ?
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          b.col = HEIGHT - BALL_HEIGHT;
          b.row = 0;
          vBlankCounter = 0;
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
